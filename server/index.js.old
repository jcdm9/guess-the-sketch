const express = require('express');
const cors = require('cors');
const http = require('http');
const { Server } = require('socket.io');

// Create express app
const app = express();

// Enable CORS for HTTP routes
app.use(cors());

// Create HTTP server
const server = http.createServer(app);

// Enable CORS for Socket.IO
const io = new Server(server, {
  cors: {
    origin: '*', // frontend origin
    methods: ['GET', 'POST']
  }
});

// Word list for the game
const words = [
  'general', 'computer', 'elephant', 'mountain', 'butterfly',
  'chocolate', 'dolphin', 'umbrella', 'guitar', 'penguin',
  'rainbow', 'diamond', 'volcano', 'octopus', 'basketball'
];

let players = [];
let gameInProgress = false;
let playerData = new Map();
let currentWord = '';
let currentClue = '';
let cluesGiven = 0;
let maxClues = 3;
let gameTimer = null;
let revealedIndices = [];
let correctGuessers = new Set();
let readyPlayers = new Set(); // Track players ready for next round

// Function to generate a clue
function generateClue(word, clueCount) {
  // For the first clue (clueCount = 0), add the first random letter
  if (clueCount === 0) {
    const randomIndex = Math.floor(Math.random() * word.length);
    revealedIndices.push(randomIndex);
  }
  // For subsequent clues, add a new random letter
  else if (clueCount > cluesGiven - 1) {
    let randomIndex;
    do {
      randomIndex = Math.floor(Math.random() * word.length);
    } while (revealedIndices.includes(randomIndex));
    revealedIndices.push(randomIndex);
  }

  // Generate the clue string with all revealed letters and underscores
  return word.split('').map((char, index) => 
    revealedIndices.includes(index) ? char : '_'
  ).join('');
}

// Function to start a new round
function startNewRound() {
  if (!gameInProgress) return; // Don't start if game is not in progress
  
  currentWord = words[Math.floor(Math.random() * words.length)];
  cluesGiven = 0;
  revealedIndices = [];
  correctGuessers.clear();
  readyPlayers.clear();
  currentClue = generateClue(currentWord, cluesGiven);
  console.log('Starting new round with word:', currentWord);
  console.log('Initial clue:', currentClue);
  io.emit('new-round', { clue: currentClue, timeLeft: 30 });
}

// Function to update and broadcast scores
function updateScores() {
  const playerScores = Array.from(playerData.entries())
    .map(([id, data]) => ({
      name: data.name,
      score: data.score
    }))
    .filter(player => player.score > 0); // Only include players with scores

  // If no one has scores yet, don't send update
  if (playerScores.length === 0) {
    io.emit('score-update', []);
    return;
  }

  // Sort players by score in descending order
  playerScores.sort((a, b) => b.score - a.score);

  // Add rank titles
  const rankedScores = playerScores.map((player, index) => {
    let title;
    if (index === 0) title = "#1 Master Guesser";
    else if (index === 1) title = "#2 Doodle Nerd";
    else title = `#${index + 1} Bottom Feeder`;
    
    return {
      ...player,
      title
    };
  });

  io.emit('score-update', rankedScores);
}

// Socket.IO connection
io.on('connection', (socket) => {
  console.log(`Player ${socket.id} connected`);

  if (gameInProgress) {
    socket.emit('game-in-progress');
    return;
  }

  players.push(socket.id);
  playerData.set(socket.id, { name: null, ready: false, score: 0 });
  console.log(`Players: ${players.length}`);

  socket.on('player-ready', (playerName) => {
    const playerInfo = playerData.get(socket.id);
    if (playerInfo) {
      playerInfo.name = playerName;
      playerInfo.ready = true;
      playerData.set(socket.id, playerInfo);
      
      const allReady = Array.from(playerData.values()).every(player => player.ready);
      if (allReady && players.length === 2) {
        gameInProgress = true;
        io.emit('start', Array.from(playerData.values()).map(p => p.name));
        // Start the first round immediately
        startNewRound();
      } else {
        socket.emit('waiting');
      }
    }
  });

  // Handle guess attempts
  socket.on('guess', (guess) => {
    if (!gameInProgress) return;

    const playerInfo = playerData.get(socket.id);
    if (!playerInfo) return;

    // Check if player already guessed correctly in this round
    if (correctGuessers.has(socket.id)) {
      socket.emit('already-guessed');
      return;
    }

    if (guess.toLowerCase() === currentWord.toLowerCase()) {
      // Calculate points based on clues given
      let points = 1;
      if (cluesGiven === 0) points = 5;
      else if (cluesGiven === 1) points = 3;
      else if (cluesGiven === 2) points = 2;

      playerInfo.score += points;
      playerData.set(socket.id, playerInfo);
      correctGuessers.add(socket.id); // Mark player as having guessed correctly

      io.emit('guess-correct', {
        player: playerInfo.name,
        word: currentWord,
        points: points,
        score: playerInfo.score
      });

      // Update scores after a correct guess
      updateScores();

      // Check if all players have guessed correctly
      const allPlayersGuessed = Array.from(playerData.keys()).every(playerId => 
        correctGuessers.has(playerId)
      );

      // Only start new round if all players have guessed correctly
      if (allPlayersGuessed) {
        setTimeout(startNewRound, 3000);
      }
    } else {
      // Send the wrong guess to all players
      io.emit('guess-wrong', `[@${playerInfo.name}]: ${guess}`);
    }
  });

  // Handle player ready for next round
  socket.on('player-ready-next', () => {
    readyPlayers.add(socket.id);
    console.log('Player ready for next round:', socket.id);
    
    // Check if all players are ready
    const allPlayersReady = Array.from(playerData.keys()).every(playerId => 
      readyPlayers.has(playerId)
    );

    if (allPlayersReady) {
      console.log('All players ready, starting new round');
      startNewRound();
    } else {
      // Notify all players about who's ready
      io.emit('waiting-for-players', {
        readyCount: readyPlayers.size,
        totalPlayers: playerData.size
      });
    }
  });

  // Handle timer updates
  socket.on('timer-update', (timeLeft) => {
    console.log('Timer update:', timeLeft, 'Clues given:', cluesGiven);
    
    if (timeLeft === 20 && cluesGiven === 0) {
      cluesGiven = 1;
      currentClue = generateClue(currentWord, cluesGiven);
      console.log('New clue at 20s:', currentClue);
      io.emit('new-clue', currentClue);
    }
    else if (timeLeft === 10 && cluesGiven === 1) {
      cluesGiven = 2;
      currentClue = generateClue(currentWord, cluesGiven);
      console.log('New clue at 10s:', currentClue);
      io.emit('new-clue', currentClue);
    }
    else if (timeLeft === 5 && cluesGiven === 2) {
      cluesGiven = 3;
      currentClue = generateClue(currentWord, cluesGiven);
      console.log('New clue at 5s:', currentClue);
      io.emit('new-clue', currentClue);
    }
    else if (timeLeft === 0) {
      // Time's up, wait for players to be ready
      io.emit('round-end');
    }
  });

  // Handle messages
  socket.on('send-message', (message) => {
    io.emit('received-message', message);
  });

  // Handle drawing
  socket.on('draw', (data) => {
    socket.broadcast.emit('draw', data);
  });

  // Handle clearing the canvas
  socket.on('clear', () => {
    console.log('cleaning..')
    socket.broadcast.emit('clear');
  });

  // When a player disconnects
  socket.on('disconnect', () => {
    players = players.filter(player => player !== socket.id);
    playerData.delete(socket.id);
    correctGuessers.delete(socket.id);
    readyPlayers.delete(socket.id); // Remove from ready players
    console.log(`Player ${socket.id} disconnected`);
    console.log(`Players: ${players.length}`);

    if (players.length < 2) {
      gameInProgress = false;
      io.emit('waiting');
    } else if (players.length === 1) {
      io.emit('waiting');
    }
    
    // Update scores when a player disconnects
    updateScores();
  });
});

// Start server
server.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});

